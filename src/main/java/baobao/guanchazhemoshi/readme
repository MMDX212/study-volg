消息队列（MQ），一种能实现生产者到消费者单向通信的通信模型，这也是现在常用的主流中间件。

常见有 RabbitMQ、ActiveMQ、Kafka等  他们的特点也有很多 比如 解偶、异步、广播、削峰 等等多种优势特点。

在设计模式中也有一种模式能有效的达到解偶、异步的特点，那就是观察者模式又称为发布订阅模式


什么是 观察者模式？ 他的目的是什么？
    当一个对象的状态发生改变时，已经登记的其他对象能够观察到这一改变从而做出自己相对于的改变，
    通过这种方式来达到减少依赖关系，解耦合的作用。

    举一个例子，就好比微信朋友圈，以当前个人作为订阅者，好友作为主题。
    一个人发一条动态朋友圈出去，他的好友都能看到这个朋友圈，并且可以在自主选择点赞或者评论。

    Subject（主题）: 主要由类实现的可观察的接口，通知观察者使用attach方法，以及取消观察的detach方法。
    ConcreteSubject（具体主题）: 是一个实现主题接口的类，处理观察者的变化
    Observe（观察者）: 观察者是一个由对象水岸的接口，根据主题中的更改而进行更新。


    先创建一个主题定义，定义添加删除关系以及通知订阅者

    其次再创建的具体主题，并且构建一个容器来维护订阅关系，支持添加删除关系，以及通知订阅者

    最后就是看测试结果了，通过ConcreteSubject 维护了一个订阅关系，在通过notifyObservers 方法通知订阅者之后，观察者都获取到消息从而处理自己的业务逻辑。


框架应用

    观察者模式在框架中的应用也是很多

    第一种  熟悉JDK的人应该知道 java.util 包下   除了常用的集合  和  map 之外 还有一个Observer 类，他的实现方式其实就是观察者模式，
    里面也有 添加 ，删除 ，通知 等方法。

    这里需要注意的是，他是用Vector  作为订阅关系的容器，同事在他的定义方法中都添加syvchronized  关键字修饰类，以达到线程安全的目的

    第二种   在Spring中有一个 A评评理擦通Listener ，也是采用观察者模式来处理的，ApplicationEventMulticaster  作为主题，里面有添加，删除，通知等。

    Spring  有一些内置事件，当完成某种操作时会发出 某些事件动作，他的处理方式也就上面的这种模式，当然里面还有很多，，，比如spring   的 启动过程

    第三种   Google guava  的事件处理机制 Guava EventBus  他的实现 也是采用 设计模式中 观察者模式。
    EventBus  当前实现有两种方式：
                EventBus   // 同步阻塞模式
                AsyncEventBus    //异步非阻塞模式

     EventBus内部也提供来一系列的方法来供我们方便使用：

     register 方法作为添加观察者

     unregister方法删除观察者

     post 方法发送通知消息等

     使用起来非常方便。添加@Subscribe注解就可以创建一个订阅者了，具体的使用方式可以看看官网。

现实业务改造举例
框架应用的例子这么多，在业务场景中其实也有很多地方可以使用到，这里我还是给大家举一个例子。

在新用户注册成功之后我们需要给用户做两件事情，第一是发送注册成功短信，第二是给用发送新人优惠券。

看到这个问题 大家可能首先会想到用MQ消息处理呀，是的，用消息确实可以的，但是这里我们用观察者模式来实现这个问题，同时可以给大家演示一下，同步或者异步的问题。


注册成功
调用发券服务，返回结果
执行异步返回
发送新人优惠券



这里我们新写了两个观察者，主要看第一个SendNewPersonCouponObserver，这里了异步开启新的线程去处理我们的业务逻辑，当我们关心返回值的时候可以用Future来获取返回结果，当不关心的返回值的化，直接开启普通线程就可以了。

这个举例整体其实还是比较简单的主要是为了说清楚异步线程处理，当然如果用Guava EventBus也可以实现。而且也不复杂，感兴趣的朋友可以自己去试试。

当前现在有更加好的中间件MQ消息队列来处理这个业务问题，使得我们更加从容的面对这类场景问题，但是一些资源不足，不想引入新的系统。还是可以用这种方式来处理问题的。


合理的使用设计模式可以使代码结构更加清晰，同时还能满足不同的小模块符合单一职责，以及开闭原则，从而达到前面写工厂模式说的，提高代码的可扩展性，维护成本低的特点。